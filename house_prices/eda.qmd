---
title: "House Prices"
author: "AG"
format: html
---

# Libraries

```{r, message=FALSE}
library(themis)
library(probably)
library(vip)
library(skimr)
library(bestNormalize) # for ord QQ norm
library(embed) # for UMAP
library(tidyverse)
library(tidymodels)
library(finetune) # fro win-loss tuning
#library(GGally)
```

# EDA

## First look at the data 

```{r}
data <- read_csv("data/train.csv", show_col_types = FALSE) 

data_submission <- read_csv("data/test.csv", show_col_types = FALSE) %>% 
  mutate(across(is_character, ~ as_factor(.x)))

dim(data)
```

I should submit price predictions for the test data set

## Factors

Here I will look at character columns and convert them into factors after NA replacement

```{r}
data %>% 
  skim() %>% 
  yank("character")
```

Notes on NAs:

- According to `data_description.txt`, NA in `Alley` means "no alley access" - should be replaced by "no access"

- NA in `MasVnrType` means "no data"

- NA in `BsmtQual`means "no basement" - should be replaced

- NA in `BsmtCond` means "no basement" - should be replaced

- NA in `BsmtExposure` means "no basement" - should be replaced

- NA in `BsmtFinType1` means "no basement" - should be replaced

- NA in `BsmtFinType2`means "no basement" - should be replaced

- NA in `Electrical` means "no data"

- NA in `FireplaceQu` means "no fireplace", should be replaced

- NA in `Garage*` means "no garage" -  should be replaced

- NA in `PoolQC` means "no pool" - should be replaced

- NA in `Fence` means "no fence" - should be replaced

- NA in `MiscFeature` means "no data"


### Replacing some NAs and converting to factors

```{r}
data <- data %>%
  mutate_at(
    vars(
      Alley,
      BsmtQual,
      BsmtCond,
      BsmtExposure,
      BsmtFinType1,
      BsmtFinType2,
      FireplaceQu,
      GarageType,
      GarageCond,
      GarageFinish,
      GarageCars,
      GarageQual,
      PoolQC,
      Fence
    ),
    ~ replace_na(., "No")
  ) %>%
  mutate(across(is_character, ~ as_factor(.x)))

data %>% 
  skim() %>% 
  yank("factor")
```


## Numerics

```{r}
data %>% 
  skim() %>% 
  yank("numeric")
```

For NA imputation I will use some kind of algorithm

# Corr. matrix for numerical predictors

```{r, fig.width=10, fig.height=10}
cor_matrix <- data %>% 
  select(where(is.numeric)) %>%
  cor(use = "pairwise.complete.obs", method = "spearman")

corrplot::corrplot(cor_matrix, type = "upper", tl.col = "black", tl.cex = 0.6, method = "ellipse")
```

Some predictors are correlated with each other.

`SalePrice` (outcome) is correlated with quite a lot of the predictors.

```{r, message=FALSE, warning=FALSE, fig.width=20, fig.height=20}
 data %>% 
  select(where(is.numeric)) %>% 
  ggpairs()
```


# Boxplots for factors

```{r, fig.width=18, fig.height=18, warning=FALSE}
make_plot <- function(sub_df) {
  ggplot(sub_df, aes(value, SalePrice)) +
    geom_boxplot(varwidth = T) +
    geom_violin(alpha = 0.1) +
    xlab("") +
    ggtitle((sub_df %>% pull(predictor))[1]) +
    theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust = 0.5, size = 8))
}

plot_list <- data %>%
  select(where(is.factor), SalePrice) %>%
  pivot_longer(cols = where(is.factor),
               names_to = "predictor",
               values_to = "value") %>%
  group_by(predictor) %>%
  group_split() %>%
  map(~ make_plot(.x))

ggpubr::ggarrange(plotlist =  plot_list, ncol = 6, nrow = 8)
```


# PCA

## Recipe

```{r}
pca_recipe <- recipe(SalePrice ~ ., data = data) %>%
  update_role(Id, new_role = "ID") %>%
  update_role(SalePrice, new_role = "outcome") %>% 
  step_nzv(all_predictors()) %>% 
  step_normalize(all_numeric_predictors()) %>%
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>%
  #step_orderNorm(all_numeric_predictors()) %>% 
  step_dummy(all_nominal_predictors()) %>% 
  step_pca(all_predictors(), threshold = .9)

data_pca <- pca_recipe %>% prep() %>% juice()

data_pca <- prep(pca_recipe, retain = TRUE)

data_pca$template %>% dim()
```

40 PCs explain 0.9 of the variance, that's good

## Explained variation

### Table

```{r}
sdev <- data_pca$steps[[6]]$res$sdev
percent_variation <- sdev^2 / sum(sdev^2)

var_df <- data.frame(PC = paste0("PC", 1:length(sdev)),
                     var_explained = percent_variation,
                     stringsAsFactors = FALSE)

var_df <- var_df %>% 
  mutate(var_cum_sum = cumsum(var_explained))

var_df
```


### Plot

40 PCs explaining 0.9 of the variance

```{r, fig.width=6, fig.height=3}
var_df %>%
  filter(var_cum_sum < .903) %>% 
  mutate(PC = forcats::fct_inorder(PC)) %>%
  ggplot(aes(x = PC, y = var_explained)) + 
  geom_col(aes(fill = var_cum_sum)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.8, hjust = 0.5, size = 8)) +
  scale_fill_continuous(type = "viridis")
```


## Scatter plot

```{r, warning=FALSE, fig.width=7}
library(ggforce)

plot_dimred_results <- function(dat, color_by = SalePrice) {
  dat %>%
    select(-Id) %>% 
    select(contains(c("01", "02", "03")), {{color_by}}) %>% 
    # Create the scatterplot matrix
    ggplot(aes(x = .panel_x, y = .panel_y, color = {{color_by}})) +
    geom_point(alpha = 0.4, size = 1) +
    geom_autodensity(alpha = .3) +
    facet_matrix(vars(-{{color_by}}), layer.diag = 2) 
}

data_pca$template %>%
  plot_dimred_results() +
  ggtitle("Principal Component Analysis")
```

# UMAP

```{r, fig.width=5, warning=FALSE}
decorq_recipe <- recipe(SalePrice ~ ., data = data) %>%
  update_role(Id, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>% 
  step_best_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>% 
  step_corr(threshold = 0.6)

## UMAP
library(embed)

umap_recipe <- decorq_recipe %>%
  step_umap(
    all_numeric_predictors(),
    num_comp = 10,
    min_dist = 0.01,
    neighbors = 25
  )

data_umap <- prep(umap_recipe, retain = TRUE)

data_umap$template %>% 
  plot_dimred_results() +
  ggtitle("UMAP")
```


# Preprocessing

Some predictors are in fact discrete (like `OverallQual`) - will this affect models?

## Data split

```{r}
library(tidymodels)

set.seed(124)

data_split <- initial_split(data, prop = 0.8)

df_train <- training(data_split)
df_test <- testing(data_split)

dim(df_train)
```


```{r}
dim(df_test)
```


## Folds and metrics

```{r}
cv_folds <- vfold_cv(df_train, v = 5, repeats = 10) 

cls_metrics <- metric_set(rmse)
```


## Recipes

### Base, decorr & decorq

```{r}
base_recipe <- recipe(SalePrice ~ ., data = df_train) %>%
  update_role(Id, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>% 
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors())

decorr_recipe <- recipe(SalePrice ~ ., data = df_train) %>%
  update_role(Id, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>% 
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>% 
  step_corr(threshold = tune("corr_tune"))

decorq_recipe <- recipe(SalePrice ~ ., data = df_train) %>%
  update_role(Id, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>% 
  step_orderNorm(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>% 
  step_corr(threshold = tune("corr_tune"))
```

### With feature selection

```{r}
library(recipeselectors)

feat_sel_recipe <- recipe(SalePrice ~ ., data = df_train) %>%
  update_role(Id, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>% 
  step_normalize(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>% 
  step_select_vip(all_predictors(), model = rf_mod, outcome = "SalePrice", threshold = 0.9)

```


# Modelling

## Basic RF

basic pre-processing recipe & space-filled grid search

```{r}
# model specification
rf_mod <- rand_forest(mtry = tune(),
                      min_n = tune(),
                      trees = 1000) %>%
  set_engine("ranger", num.threads = 8) %>%
  set_mode("regression")

# model workflow
rf_wf <- workflow() %>%
  add_model(rf_mod) %>%
  add_recipe(base_recipe)

# tuning and resampling
rf_base_res <- rf_wf %>%
  tune_grid(
    grid = 20,
    resamples = cv_folds,
    control = control_grid(save_pred = TRUE,
                           save_workflow = TRUE),
    metrics = cls_metrics
  )

```

### Autoplot

```{r}
autoplot(rf_base_res)
```

### Best models

```{r}
rf_best <- rf_base_res %>% select_best()
rf_base_res %>% show_best()
```

## Basic LR

### Decorrelated predictors

```{r}

# model specs
lr_mod <- linear_reg(penalty = tune(),
                      mixture = tune()) %>%
  set_engine("glmnet", num.threads = 8) %>%
  set_mode("regression")

# model's workflow
lr_wf <- workflow() %>%
  add_model(lr_mod) %>%
  add_recipe(decorr_recipe)

# tuning and resampling
lr_decorr_res <- lr_wf %>%
  tune_grid(
    grid = 20,
    resamples = cv_folds,
    control = control_grid(save_pred = TRUE,
                           save_workflow = TRUE),
    metrics = cls_metrics
  )

```

#### Autoplot

```{r}
autoplot(lr_decorr_res)
```

#### Best models

```{r}
lr_best <- lr_decorr_res %>% 
  select_best()

lr_decorr_res %>% 
  show_best()
```

### PCA recipe

```{r}
lr_pca_wf <- workflow() %>%
  add_model(lr_mod) %>%
  add_recipe(pca_recipe)

lr_pca_res <- lr_pca_wf %>%
  tune_grid(
    grid = 20,
    resamples = cv_folds,
    control = control_grid(save_pred = TRUE,
                           save_workflow = TRUE),
    metrics = cls_metrics
  )

```

#### Autoplot

```{r}
autoplot(lr_pca_res)
```

#### Best models

```{r}
show_best(lr_pca_res)
```


## MLP

### PCA

```{r}
mlp_mod <-
  mlp(hidden_units = tune(),
      penalty = tune(),
      epochs = tune()) %>%
  set_mode("regression") %>%
  set_engine("nnet", num.threads = 8)

mlp_wf <- workflow() %>% 
  add_model(mlp_mod) %>% 
  add_recipe(pca_recipe)

mlp_res <- mlp_wf %>%
  tune_grid(
    grid = 20,
    resamples = cv_folds,
    control = control_grid(save_pred = TRUE,
                           save_workflow = TRUE),
    metrics = cls_metrics
  )

autoplot(mlp_res)
```

```{r}
show_best(mlp_res)
```


### Decorrelated predictors & ORQ transformation

#### Recipe

```{r}
decorq_na_recipe <- recipe(SalePrice ~ ., data = df_train) %>%
  update_role(Id, new_role = "ID") %>% 
  step_nzv(all_predictors()) %>%
  step_filter_missing(all_predictors()) %>% 
  step_impute_mean(all_numeric_predictors()) %>% 
  step_impute_knn(all_nominal_predictors()) %>% 
  step_orderNorm(all_numeric_predictors()) %>%
  step_dummy(all_nominal_predictors()) %>% 
  step_lincomb(all_predictors()) %>% 
  step_corr(threshold = tune("corr_tune"))
```

#### Tuning

```{r}
mlp_decorq_wf <- workflow() %>% 
  add_model(mlp_mod) %>% 
  add_recipe(decorq_na_recipe)

mlp_decorq_res <- mlp_decorq_wf %>%
  tune_grid(
    grid = 20,
    resamples = cv_folds,
    control = control_grid(save_pred = TRUE,
                           save_workflow = TRUE),
    metrics = cls_metrics
  )

```

#### Autoplot

```{r}
autoplot(mlp_decorq_res)
```

#### Best models

```{r}
mlp_decorq_res %>% show_best()
```

## XGB

### Boosted trees specification

```{r}
# xgb_spec <-
#   boost_tree(
#     tree_depth = tune(),
#     trees = tune(),
#     learn_rate = tune(),
#     min_n = tune(),
#     loss_reduction = tune(),
#     sample_size = tune(),
#     stop_iter = tune()
#   ) %>%
#   set_engine('xgboost', num.threads = 8) %>%
#   set_mode('regression')

xgb_spec <- boost_tree(
  trees = 50,
  mtry = tune(),
  min_n = tune(),
  tree_depth = tune(),
  learn_rate = tune(),
  loss_reduction = tune(),
  sample_size = tune(),
  stop_iter = tune()
) %>%
  set_engine("xgboost", num.threads = 8) %>%
  set_mode("regression")
```


### Basic preprocessing and win-loss grid search

```{r}
xgb_wf <- workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(base_recipe)

param_set <- extract_parameter_set_dials(xgb_wf) %>%
  finalize(x = df_train %>% select(-SalePrice))

xgb_wl_res <- xgb_wf %>%
  tune_race_win_loss(
    param_info = param_set,
    resamples = cv_folds,
    grid = 40,
    control = control_race(
      verbose_elim = TRUE,
      save_pred = TRUE,
      save_workflow = TRUE,
      burn_in = 10
    )
  )

plot_race(xgb_wl_res)
```

#### Autoplot

```{r}
autoplot(xgb_wl_res)
```


#### Best models

```{r}
xgb_wl_res %>% show_best("rmse")
```


### Decorrelated recipe and win-loss search

```{r}
# xgb specification is the same as above
xgb_wf <- workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(decorr_recipe)

param_set <- extract_parameter_set_dials(xgb_wf) %>%
    finalize(x = df_train %>% select(-SalePrice))

xgb_dec_wlres <- xgb_wf %>%
  tune_race_win_loss(
    param_info = param_set,
    resamples = cv_folds,
    grid = 20,
    control = control_race(
      verbose_elim = TRUE,
      save_pred = TRUE,
      save_workflow = TRUE,
      burn_in = 10
    )
  )

plot_race(xgb_dec_wl_res)
```

#### Autoplot

```{r}
autoplot(xgb_dec_wlres)
```


#### Best models

```{r}
xgb_dec_wlres %>% show_best("rmse")
```


### Basic recipe and Bayesian search from win-loss resamples

Here, I will use the winning combinations of hyper-parameters (`xgb_wl_res`) as starting points for Bayesian grid search. 

```{r, eval=FALSE}
xgb_wf <- workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(base_recipe)

xgb_bwl_res <- xgb_wf %>%
    tune_bayes(
      resamples = cv_folds,
      param_info = param_set,
      initial = xgb_wl_res,
      iter = 50,
      metrics = cls_metrics,
      control = control_bayes(
        no_improve = 20,
        verbose = FALSE,
        save_pred = TRUE,
        save_workflow = TRUE
      )
    )
```

```{r, eval=FALSE}
xgb_bwl_res %>% show_best("rmse")
```


### Basic recipe and full Bayesian search

30 iterations

```{r}
xgb_wf <- workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(base_recipe)

param_set <- extract_parameter_set_dials(xgb_wf) %>%
    finalize(x = df_train %>% select(-SalePrice))

xgb_bres <- xgb_wf %>%
    tune_bayes(
      resamples = cv_folds,
      param_info = param_set,
      initial = 20,
      iter = 30,
      metrics = cls_metrics,
      control = control_bayes(
        no_improve = 20,
        verbose = FALSE,
        save_pred = TRUE,
        save_workflow = TRUE
      )
    )

xgb_bres %>% show_best("rmse")
```

#### Autoplot

```{r, fig.width=5}
autoplot(xgb_bres)
```


### Decorrelated recipe and Bayesian search

30 iterations

```{r}
xgb_wf <- workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(decorr_recipe)

param_set <- extract_parameter_set_dials(xgb_wf) %>%
    finalize(x = df_train %>% select(-SalePrice))

xgb_dec_bres <- xgb_wf %>%
    tune_bayes(
      resamples = cv_folds,
      param_info = param_set,
      initial = 20,
      iter = 30,
      metrics = cls_metrics,
      control = control_bayes(
        no_improve = 20,
        verbose = FALSE,
        save_pred = TRUE,
        save_workflow = TRUE
      )
    )

xgb_dec_bres %>% show_best("rmse")
```

#### Autoplot

```{r, fig.width=7}
autoplot(xgb_dec_bres)
```


# Compare mean RMSE between different model specifications

```{r}
# function to retrieve the best HP combination based on mean RMSE
best_rmse <- function(res_obj, name){
  res_obj %>% 
    show_best("rmse") %>% 
    select(mean, std_err) %>%
    mutate(model = name) %>% 
    slice_head(n = 1)
}

# make a data frame
best_models_rmse <-
  map2_dfr(
    list(
      rf_base_res,
      lr_decorr_res,
      lr_pca_res,
      mlp_res,
      mlp_decorq_res,
      xgb_wl_res,
      xgb_bres,
      xgb_dec_bres
    ),
    c(
      "RF basic",
      "LR no corr",
      "LR pca",
      "MLP pca",
      "MLP no corr ORQ",
      "XGB wl",
      "XGB Bayes",
      "XGB no corr Bayes"
    ),
    ~ best_rmse(.x, .y)
  )

ggplot(best_models_rmse,
       aes(
         y = mean,
         x = model,
         ymin = mean - std_err,
         ymax = mean + std_err
       )) +
  geom_errorbar(aes(color = model)) +
  geom_point(aes(y = mean, color = model)) +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.95, hjust=1)) +
  xlab("") +
  ylab("RMSE")
```

## Bayesian ANOVA

```{r}
library(tidyposterior)

# function to get a name of the best preprocessor from your resample
best_preprocessor <- function(res_obj) {
  res_obj %>% 
    select_best("rmse") %>% 
    pull(.config)
}

# function to make a df with AUCs from the best preproc
best_rmse <- function(res_obj, model_name){
  res_obj %>%
    collect_metrics(summarize = FALSE) %>%
    filter(.metric == "rmse", .config == best_preprocessor(res_obj)) %>%
    select(id, id2, {{model_name}} := .estimate)
}

# generate distributions
resampling_comparison <-
  map2(list(rf_base_res, lr_decorr_res, xgb_wl_res),
       c("RF", "LR", "XGB wl"),
       ~ best_rmse(res_obj = .x, model_name = .y)) %>% 
  reduce(inner_join, by = c("id", "id2")) %>% 
  rename("rf" = .y.x, "lr" = .y.y, "xgb" = .y) %>% 
  unite(id, id, id2)

# make ANOVA
resampling_posterior <-
  perf_mod(
    resampling_comparison,
    iter = 10000,
    seed = 100,
    refresh = 0,
    chains = 4,
    cores = 4
  )

# plot
autoplot(resampling_posterior)
```

### Estimate the difference

```{r}
res_diff <- contrast_models(resampling_posterior, seed = 100) 

summary(res_diff)
```

XGB has significantly better RMSE

# Final fit

```{r}
# tuned recipe
# best_corr <- xgb_wl_res %>% 
#   select_best("rmse") %>% 
#   pull(corr_tune)

# ncorr_recipe_tuned <- recipe(resistance ~ ., data = df_train) %>%
#   update_role(strain, new_role = "ID") %>% 
#   step_nzv(all_predictors()) %>%
#   step_normalize(all_numeric_predictors()) %>%
#   step_dummy(all_nominal_predictors()) %>%
#   step_corr(threshold = best_corr) %>% # tuned threshold
#   step_smote(resistance, over_ratio = 1, seed = 100)

# model spec
#xgb_mod <- set_model("bt", 8)

xgb_spec <- boost_tree(
  trees = 50,
  mtry = tune(),
  min_n = tune(),
  tree_depth = tune(),
  learn_rate = tune(),
  loss_reduction = tune(),
  sample_size = tune(),
  stop_iter = tune()
) %>%
  set_engine("xgboost", num.threads = 8) %>%
  set_mode("regression")

# main or ncorr?
best_mod <- xgb_wl_res %>% 
  select_best("rmse")

# use hyper parameters of the best model
last_mod <-
  boost_tree(
    mtry = best_mod$mtry,
    min_n = best_mod$min_n,
    tree_depth = best_mod$tree_depth,
    learn_rate = best_mod$learn_rate,
    loss_reduction = best_mod$loss_reduction,
    sample_size = best_mod$sample_size,
    stop_iter = best_mod$stop_iter
  ) %>% 
  set_engine("xgboost", num.threads=8) %>% 
  set_mode("regression") 

# this was the XGB workflow
xgb_wf <- workflow() %>% 
  add_model(xgb_spec) %>% 
  add_recipe(base_recipe) # the recipe here should be the one that was used for this model

# the last workflow
last_wf <- 
  xgb_wf %>%  
  update_model(last_mod)

# the last fit
set.seed(345)

final_fit <- 
  last_wf %>% 
  last_fit(data_split)

# emulates the process where, after determining the best model, 
# the final fit on the entire training set is needed 
# and is then evaluated on the test set.

final_fit %>% 
  collect_metrics()
```

