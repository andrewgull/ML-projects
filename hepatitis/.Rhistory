scale_color_viridis_d(option = "plasma", end = .6)
load("data/xgb_model.RData")
autoplot(xgb_res)
xgb_res %>%
show_best(metric = "roc_auc")
xgb_res %>%
show_best(metric = "j_index")
xgb_best <- xgb_res %>%
select_best(metric = "roc_auc")
xgb_best
xgb_auc <- xgb_res %>%
collect_predictions(parameters = xgb_best) %>%
roc_curve(Diagnosis, .pred_Hepatitis) %>%
mutate(model = "Boosted Trees")
autoplot(xgb_auc)
bind_rows(rf_auc, lr_auc, xgb_auc) %>%
ggplot(aes(x = 1 - specificity, y = sensitivity, col = model)) +
geom_path(lwd = 1, alpha = 0.8) +
geom_abline(lty = 3) +
coord_equal() +
scale_color_viridis_d(option = "plasma", end = .6)
data_split
str(data_split)
?last_fit
autoplot(last_rf_fit)
last_rf_fit %>%
extract_fit_parsnip() %>%
vip()
last_rf_fit %>%
extract_fit_parsnip() %>%
vip(num_features = 15)
last_rf_fit %>%
extract_fit_parsnip() %>%
vip(num_features = 12)
xgb_best
# the last model
last_xgb_mod <-
boost_tree(trees = 50,
mtry = xgb_best$mtry,
min_n = xgb_best$min_n,
tree_depth = xgb_best$tree_depth,
learn_rate = xgb_best$learn_rate,
loss_reduction = xgb_best$loss_reduction,
sample_size = xgb_best$sample_size,
stop_iter = xgb_best$stop_iter) %>%
set_engine("xgboost", num.threads = cores) %>%
set_mode("classification")
# the last workflow
last_xgb_wf <-
xgb_cv_wf %>%
update_model(last_xgb_mod)
# the last fit
set.seed(345)
last_xgb_fit <-
last_xgb_wf %>%
last_fit(data_split)
last_xgb_fit %>%
collect_metrics()
last_xgb_fit %>%
extract_fit_parsnip() %>%
vip(num_features = 12)
last_xgb_fit %>%
collect_predictions() %>%
roc_curve(Diagnosis, .pred_Hepatitis) %>%
autoplot()
mean_pred <- predict(last_xgb_fit)
last_xgb_fit
last_xgb_fit$splits
last_xgb_fit$.metrics
last_xgb_fit$.predictions
conf_mat(last_xgb_fit)
conf_mat(data = last_xgb_fit$.predictions, truth = Diagnosis, estimate = .pred_class)
conf_mat(data = last_xgb_fit$.predictions[[1]], truth = Diagnosis, estimate = .pred_class)
cm <- conf_mat(data = last_xgb_fit$.predictions[[1]], truth = Diagnosis, estimate = .pred_class)
autoplot(cm, type = "heatmap")
autoplot(cm, type = "mosaic")
summary(cm)
last_xgb_fit %>%
collect_predictions()
last_xgb_fit %>%
collect_predictions() %>%
conf_mat(truth = Diagnosis, estimate = .pred_class)
cm <- last_xgb_fit %>%
collect_predictions() %>%
conf_mat(truth = Diagnosis, estimate = .pred_class)
autoplot(cm, type = "heatmap")
autoplot(cm, type = "heatmap")
summary(cm)
last_xgb_fit %>%
collect_metrics()
last_xgb_fit %>%
collect_predictions()
?collect_metrics
?roc_curve()
last_xgb_fit %>%
collect_predictions() %>%
roc_curve(Diagnosis, .pred_Hepatitis)
?conf_mat
?last_fit
save.image("data/workspace.RData")
parsnip:::parsnip_addin()
View(model_db)
View(model_db[[7]][[23]])
View(model_db[[7]][[8]])
parsnip:::parsnip_addin()
data(cars)
cars |> head()
plot(cars$speed, cars$dist)
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, cache = T)
library(tidymodels)
library(skimr)
library(readr)
library(stringr)
library(themis) # for SMOTE and other recipes for target balancing
library(vip) # for variable importance
df <- read_csv("data/HepatitisCdata.csv", col_types = "dfdfdddddddddd") %>% select(-...1)
# make re-coded Category variable
# there is 0=Blood Donor and 0s=suspect Blood Donor
df <- df %>%
mutate(Diagnosis = if_else(str_detect(Category, "Donor"), "Donor", "Hepatitis")) %>%
mutate(Diagnosis = factor(Diagnosis, levels = c("Hepatitis", "Donor"))) %>%
relocate(Diagnosis, .before = Category) %>%
select(-Category)
head(df)
set.seed(124)
data_split <- initial_split(df, prop = 3/4, strata = Diagnosis)
df_train <- training(data_split)
df_test <- testing(data_split)
# make a validation set
# to test a model on 0.8 of the test data set, validate on 0.2
val_set <- validation_split(df_train,
strata = Diagnosis,
prop = 0.80)
my_recipe <- recipe(Diagnosis ~ ., data = df_train) %>%
step_impute_median(all_numeric_predictors()) %>% # I use median bcz not that many observations are missing
step_dummy(all_nominal_predictors()) %>% # dummy goes before normalisation
step_normalize(all_predictors()) %>%
step_smote(Diagnosis, over_ratio = 1, seed = 100) %>% # original target distribution 399 v 62
check_missing(all_predictors())
my_recipe
# number of cores available on Kaggle
cores <- 4L
# model specification
rf_mod <-
rand_forest(mtry = tune(), min_n = tune(), trees = 1000) %>%
set_engine("ranger", num.threads = cores) %>%
set_mode("classification")
# join model and processing recipe
rf_cv_wf <- workflow() %>%
add_model(rf_mod) %>%
add_recipe(my_recipe)
rf_cv_wf
getwd()
install.packages("probably")
install.packages("probably")
load("data/workspace.RData")
last_xgb_fit %>%
collect_predictions()
library(tidymodels)
last_xgb_fit %>%
collect_predictions()
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, cache = T)
library(tidymodels)
library(skimr) # descriptive stats
library(readr) # reading csv, from tidyverse
library(stringr) # same idea
library(themis) # for SMOTE and other recipes for target balancing
library(vip) # for variable importance
library(probably) # for performance calibration
last_xgb_fit %>%
collect_predictions() %>%
roc_curve(Diagnosis, .pred_Hepatitis) %>%
autoplot()
cm <- last_xgb_fit %>%
collect_predictions() %>%
conf_mat(truth = Diagnosis, estimate = .pred_class)
autoplot(cm, type = "heatmap")
last_xgb_fit %>%
collect_predictions() %>%
mutate(
.pred = make_two_class_pred(
estimate = .pred_Hepatitis,
levels = levels(Diagnosis),
threshold = 0.5
)
)
hard_pred_05 <- last_xgb_fit %>%
collect_predictions() %>%
mutate(
.pred = make_two_class_pred(
estimate = .pred_Hepatitis,
levels = levels(Diagnosis),
threshold = 0.5
)
) %>%
select(Diagnosis, contains(".pred"))
hard_pred_05 %>%
count(.truth = Diagnosis, .pred)
hard_pred_0.75 <- last_xgb_fit %>%
collect_predictions() %>%
mutate(
.pred = make_two_class_pred(
estimate = .pred_Hepatitis,
levels = levels(Diagnosis),
threshold = .75
)
) %>%
select(Diagnosis, contains(".pred"))
hard_pred_0.75 %>%
count(.truth = Diagnosis, .pred)
sens(hard_pred_05, Diagnosis, .pred_Hepatitis)
hard_pred_05
hard_pred_0.75
sens(hard_pred_05, Diagnosis, .pred)
spec(hard_pred_05, Diagnosis, .pred)
sens(hard_pred_05, Diagnosis, .pred)
spec(hard_pred_05, Diagnosis, .pred)
yardstick::spec(hard_pred_05, Diagnosis, .pred)
sens(hard_pred_0.75, Diagnosis, .pred)
yardstick::spec(hard_pred_0.75, Diagnosis, .pred)
sens(hard_pred_05, Diagnosis, .pred)
threshold_data <- last_xgb_fit %>%
collect_predictions() %>%
threshold_perf(Diagnosis, .pred_Hepatitis, thresholds = seq(0.5, 1, by = 0.0025))
threshold_data %>%
filter(.threshold %in% c(0.5, 0.6, 0.7))
library(ggplot2)
threshold_data <- threshold_data %>%
filter(.metric != "distance") %>%
mutate(group = case_when(
.metric == "sens" | .metric == "spec" ~ "1",
TRUE ~ "2"
))
max_j_index_threshold <- threshold_data %>%
filter(.metric == "j_index") %>%
filter(.estimate == max(.estimate)) %>%
pull(.threshold)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line() +
theme_minimal() +
scale_color_viridis_d(end = 0.9) +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "'Hepatitis' Threshold\n(above this value is considered 'good')",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold",
subtitle = "Sensitivity or specificity alone might not be enough!\nVertical line = Max J-Index"
)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line() +
theme_minimal() +
scale_color_viridis_d(end = 0.9) +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
#geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold",
subtitle = "Sensitivity or specificity alone might not be enough!\nVertical line = Max J-Index"
)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(lw=1) +
theme_minimal() +
scale_color_viridis_d(end = 0.9) +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
#geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold",
subtitle = "Sensitivity or specificity alone might not be enough!\nVertical line = Max J-Index"
)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(lw=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set2") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
#geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold",
subtitle = "Sensitivity or specificity alone might not be enough!\nVertical line = Max J-Index"
)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(lw=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
#geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold",
subtitle = "Sensitivity or specificity alone might not be enough!\nVertical line = Max J-Index"
)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(lw=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
#geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
threshold_data <- last_xgb_fit %>%
collect_predictions() %>%
threshold_perf(Diagnosis, .pred_Hepatitis, thresholds = seq(0.0, 1, by = 0.05))
threshold_data %>%
filter(.threshold %in% c(0.5, 0.6, 0.7))
library(ggplot2)
threshold_data <- threshold_data %>%
filter(.metric != "distance") %>%
mutate(group = case_when(
.metric == "sens" | .metric == "spec" ~ "1",
TRUE ~ "2"
))
max_j_index_threshold <- threshold_data %>%
filter(.metric == "j_index") %>%
filter(.estimate == max(.estimate)) %>%
pull(.threshold)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(lw=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
#geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(lw=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
save.image("~/Projects/ML-projects/hepatitis/data/workspace.RData")
max_j_index_threshold
hard_pred_opt <- last_xgb_fit %>%
collect_predictions() %>%
mutate(
.pred = make_two_class_pred(
estimate = .pred_Hepatitis,
levels = levels(Diagnosis),
threshold = max_j_index_threshold
)
) %>%
select(Diagnosis, contains(".pred"))
hard_pred_opt %>%
count(.truth = Diagnosis, .pred)
sens(hard_pred_opt, Diagnosis, .pred)
yardstick::spec(hard_pred_opt, Diagnosis, .pred)
hard_pred_opt
cm_opt <- hard_pred_opt %>%
conf_mat(truth = Diagnosis, estimate = .pred_class)
autoplot(cm_opt, type = "heatmap")
cm_opt <- hard_pred_opt %>%
conf_mat(truth = Diagnosis, estimate = .pred)
autoplot(cm_opt, type = "heatmap")
summary(cm_opt)
last_xgb_fit %>%
extract_fit_parsnip() %>%
vip(num_features = 12)
?geom_line
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F, cache = T)
library(tidymodels)
library(skimr) # descriptive stats
library(stringr) # same idea
library(themis) # for SMOTE and other recipes for target balancing
library(vip) # for variable importance
library(probably) # for performance calibration
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30", linetype = "dotdash") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .6, color = "grey30", linetype = "longdash") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .8, color = "grey30", linetype = "longdash") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Balancing performance by varying the threshold"
)
pred_optimized <- last_xgb_fit %>%
collect_predictions() %>%
mutate(
.pred = make_two_class_pred(
estimate = .pred_Hepatitis,
levels = levels(Diagnosis),
threshold = max_j_index_threshold
)
) %>%
select(Diagnosis, contains(".pred"))
cm_optimized <- pred_optimized %>%
conf_mat(truth = Diagnosis, estimate = .pred)
autoplot(cm_optimized, type = "heatmap")
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .8, color = "grey30", linetype = "longdash") +
labs(
x = "probability cutoff",
y = "Metric Estimate",
title = "Choosing the optimal probability cut-off"
)
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .8, color = "grey30", linetype = "longdash") +
labs(
x = "probability",
y = "Metric Estimate",
title = "Choosing the optimal probability cut-off"
)
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .8, color = "grey30", linetype = "longdash") +
labs(
x = "Probability",
y = "Metric Estimate",
title = "Choosing the optimal probability cut-off"
)
# plot metrics v cut-offs
ggplot(threshold_data, aes(x = .threshold, y = .estimate, color = .metric, alpha = group)) +
geom_line(size=1) +
#theme_minimal() +
#scale_color_viridis_d(end = 0.9) +
scale_color_brewer(palette = "Set1") +
scale_alpha_manual(values = c(.4, 1), guide = "none") +
geom_vline(xintercept = max_j_index_threshold, alpha = .8, color = "grey30", linetype = "longdash") +
labs(
x = "Probability",
y = "Metric Estimate",
title = "Choosing the optimal probability cut-off"
)
last_xgb_fit %>%
collect_metrics()
save.image("data/workspace.RData")
ggplot(df, aes(Diagnosis, Age)) +
geom_violin(aes(fill = Diagnosis), alpha = 0.5) +
geom_jitter(alpha = 0.5, size = 0.6) +
geom_boxplot(aes(fill = Diagnosis), alpha = 0.2) +
scale_fill_brewer(palette = "Set1", direction = -1) +
xlab("")
